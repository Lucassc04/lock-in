package lucas.lockIn.lockIn_backend.auth.service;

import jakarta.validation.Valid;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import lombok.AllArgsConstructor;
import lucas.lockIn.lockIn_backend.auth.dto.request.LoginRequest;
import lucas.lockIn.lockIn_backend.auth.dto.request.RegisterRequest;
import lucas.lockIn.lockIn_backend.auth.dto.response.TokenResponse;
import lucas.lockIn.lockIn_backend.auth.entity.User;
import lucas.lockIn.lockIn_backend.auth.entity.UserPrincipal;
import lucas.lockIn.lockIn_backend.auth.exceptions.InvalidCredentialsException;
import lucas.lockIn.lockIn_backend.auth.exceptions.InvalidRefreshToken;
import lucas.lockIn.lockIn_backend.workout.exceptions.EntityNotFoundException;
import org.apache.tomcat.util.http.SameSiteCookies;
import org.springframework.http.ResponseCookie;
import org.springframework.stereotype.Service;

import java.time.Duration;
import java.util.Date;

/**
 * Service responsible for managing user authentication and token generation using JWT.
 * <p>
 * This service provides functionality for user registration, login, access token generation,
 * and refresh token cookie creation. It integrates with {@link UserService} to manage user
 * persistence and {@link JwtService} to handle JWT creation, validation, and extraction.
 * </p>
 *
 * <p>All tokens generated by this service follow the JWT standard and are used for
 * stateless authentication. The refresh tokens are stored in HTTP-only cookies for
 * enhanced security.</p>
 *
 * @author Lucas
 * @see UserService
 * @see JwtService
 * @see TokenResponse
 */
@AllArgsConstructor
@Service
public class AuthenticationService {

    private final UserService userService;
    private final JwtService jwtService;

    /**
     * Registers a new user based on the provided registration request.
     *
     * @param registerRequest the {@link RegisterRequest} object containing user registration data
     * @return a {@link UserPrincipal} representing the newly registered user
     *
     * @throws jakarta.validation.ConstraintViolationException if validation fails
     */
    public UserPrincipal registerUser(@Valid RegisterRequest registerRequest) {
        return userService.createUser(registerRequest);
    }

    /**
     * Authenticates a user based on the provided login credentials and issues a JWT access token.
     *
     * @param loginRequest the {@link LoginRequest} containing username and password
     * @return a {@link TokenResponse} containing the generated JWT and {@link UserPrincipal}
     *
     * @throws InvalidCredentialsException if the username or password is incorrect
     */
    public TokenResponse loginUser(@Valid LoginRequest loginRequest) {
        try {
            User user = userService.verifyLogIn(loginRequest);
            String token = jwtService.generateToken(user.getUsername(), user.getId());
            return new TokenResponse(token, new UserPrincipal(user));
        } catch (EntityNotFoundException e) {
            throw new InvalidCredentialsException("Invalid username or password");
        }
    }

    /**
     * Issues a new access token based on a valid refresh token.
     *
     * @param refreshCookie the refresh token extracted from the HTTP cookie
     * @return a {@link TokenResponse} containing a new JWT access token and user information
     *
     * @throws InvalidRefreshToken if the provided refresh token is invalid or expired
     */
    public TokenResponse requestAccessToken(@NotBlank String refreshCookie) {
        boolean validated = jwtService.validateToken(refreshCookie);
        if (validated) {
            String username = jwtService.extractUsername(refreshCookie);
            Long userId = jwtService.extractUserId(refreshCookie);
            String token = jwtService.generateToken(username, userId);
            return new TokenResponse(token, new UserPrincipal(userId, username));
        }
        throw new InvalidRefreshToken("Refresh token is invalid! Please login again");
    }

    /**
     * Creates a secure HTTP-only cookie containing a refresh JWT token for the specified user.
     *
     * @param userPrincipal the authenticated user's principal
     * @return a {@link ResponseCookie} object containing the secure refresh token cookie
     */
    public ResponseCookie requestRefreshCookie(@Valid @NotNull UserPrincipal userPrincipal) {
        String cookieToken = jwtService.generateCookie(userPrincipal.getUsername(), userPrincipal.getUserId());
        Long duration = fetchTokenDuration(cookieToken);

        return ResponseCookie.from("REFRESH", cookieToken)
                .httpOnly(true)
                .secure(true)
                .path("/")
                .maxAge(duration)
                .sameSite(SameSiteCookies.STRICT.toString())
                .build();
    }

    /**
     * Calculates the duration (in seconds) between the issuance and expiration times of a JWT token.
     *
     * @param token the JWT token
     * @return the token's valid duration in seconds
     */
    private Long fetchTokenDuration(String token) {
        Date start = jwtService.extractIssuance(token);
        Date end = jwtService.extractExpiration(token);

        return Duration.between(start.toInstant(), end.toInstant()).getSeconds();
    }
}
